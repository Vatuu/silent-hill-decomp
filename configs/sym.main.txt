// main .rodata
g_OvlDynamic = 0x80010000; // type:u32
g_OvlBodyprog = 0x80010004; // type:u32
// main .text
main = 0x80010770; // type:func
// main .data
g_MainDispEnv = 0x800212dc; // type:DISPENV size:0x14
g_MainDrawEnv = 0x800212f0; // type:DRAWENV size:0x5c
// main .sdata
g_MainImg0 = 0x80022C74; // type:FsImageDesc size:8
g_MainImg1 = 0x80022C7c; // type:FsImageDesc size:8
g_MainFbIdx = 0x80022C84; // type:u32

// fileinfo .text
Fs_DecryptOverlay = 0x80010AD0; // type:func
Fs_GetFileSize = 0x80010B24; // type:func
Fs_GetFileName = 0x80010b54; // type:func
Fs_GetFileInfoName = 0x80010b88; // type:func
Fs_EncodeFileName = 0x80010c60; // type:func
Fs_GetFileSectorAlignedSize = 0x80010cd4; // type:func
Fs_FindNextFileOfType = 0x80010d0c; // type:func
Fs_FindNextFile = 0x80010d80; // type:func
// fileinfo .data
g_FileTable = 0x8001B11C; // type:FileInfo size:0x6138
g_FilePaths = 0x80021254; // type:u32 size:0x2C
g_FileExts = 0x80021280; // type:u32 size:0x30
g_FileXaLoc = 0x800212b0; // type:u32 size:44
// fileinfo .sdata

// fsqueue .rodata
a_PcDrvPath = 0x80010008; // type:asciz
// fsqueue .text
Fs_QueueIsEntryLoaded = 0x80010e58; // type:func // Unsure.
Fs_QueueGetLength = 0x80010E68; // type:func
Fs_QueueDoThingWhenEmpty = 0x80010e84; // type:func // Unsure. Calls into BODYPROG and touches fsqueue.
Fs_QueueWaitForEmpty = 0x80010ecc; // type:func // Spin wait for GetLength() < 1 with VSync/DrawSync and calls to BODYPROG. Loading screen?
Fs_QueueStartSeek = 0x80010f34; // type:func
Fs_QueueStartRead = 0x80010F68; // type:func
Fs_QueueStartReadTim = 0x80010F9C; // type:func
Fs_QueueStartReadAnm = 0x80011018; // type:func // Unsure. Causes Fs_QueuePostLoadAnm later.
Fs_QueueEnqueue = 0x80011074; // type:func
Fs_QueueInitialize = 0x80011170; // type:func
Fs_QueueReset = 0x800111dc; // type:func // Unsure. Resets part of queue.
Fs_QueueUpdate = 0x80011260; // type:func
Fs_QueueUpdateSeek = 0x8001137C; // type:func
Fs_QueueUpdateRead = 0x800114C4; // type:func
Fs_QueueAllocEntryData = 0x80011630; // type:func
Fs_QueueCanRead = 0x800116BC; // type:func
Fs_QueueDoBuffersOverlap = 0x800117AC; // type:func
Fs_QueueTickSetLoc = 0x800117E8; // type:func
Fs_QueueTickRead = 0x8001182C; // type:func
Fs_QueueResetTick = 0x80011884; // type:func
Fs_QueueTickReadPcDvr = 0x8001190c; // type:func
Fs_QueueUpdatePostLoad = 0x80011A4C; // type:func
Fs_QueuePostLoadTim = 0x80011B24; // type:func
Fs_QueuePostLoadAnm = 0x80011C3C; // type:func // Unsure. Calls into BODYPROG, which then uses GsCOORDINATE2.
// fsqueue .bss
g_FsQueue = 0x80022c98; // type:FsQueue size:0x428

// fsmem .text
Fs_InitializeMem = 0x80011C70; // type:func
nullsub_80011cfc = 0x80011cfc; // type:func
Fs_AllocMem = 0x80011D04; // type:func
Fs_ClampMemBlock = 0x80011E4C; // type:func
Fs_FreeMem = 0x80011ed0; // type:func
Fs_RelinkMemBlock = 0x80011F48; // type:func
// fsmem .bss
g_FsMem = 0x800230c0; // type:FsMemState size:0xe0

// memcpy .text
memcpy = 0x80011F78; // type:func
nullsub_800120b0 = 0x800120b0; // type:func

// rng .text
Rng_Rand32 = 0x800120b8; // type:func
Rng_Rand16 = 0x800120e4; // type:func
Rng_GetSeed = 0x80012104; // type:func
Rng_SetSeed = 0x80012110; // type:func
Rng_Rand12 = 0x8001211c; // type:func
// rng .sdata
g_RngSeed = 0x80022c90; // type:u32

// memmove32 .text
Mem_Move32 = 0x8001213c; // type:func

// psyq
EnterCriticalSection = 0x800121bc;
ExitCriticalSection = 0x800121cc;
open = 0x800121dc;
read = 0x800121ec;
close = 0x800121fc;
OpenEvent = 0x8001220c;
EnableEvent = 0x8001221c;
strcat = 0x8001222c;
strcmp = 0x8001223c;
bzero = 0x8001224c;
memset = 0x8001225c;
SpuInit = 0x8001226c;
_SpuInit = 0x8001228c;
SpuStart = 0x80012374;
_spu_init = 0x800123ec;
_spu_FwriteByIO = 0x8001266c;
_spu_FiDMA = 0x8001282c;
_spu_Fr_ = 0x800128e8;
_spu_t = 0x80012990;
_spu_Fw = 0x80012c10;
_spu_Fr = 0x80012c94;
_spu_FsetRXX = 0x80012cf8;
_spu_FsetRXXa = 0x80012d3c;
_spu_FgetRXXa = 0x80012de0;
_spu_FsetPCR = 0x80012e1c;
_spu_FsetDelayW = 0x80012e74;
_spu_FsetDelayR = 0x80012e9c;
_spu_Fw1ts = 0x80012ec4;
DeliverEvent = 0x80012f2c;
printf = 0x80012f3c;
_SpuDataCallback = 0x80012f4c;
__SN_ENTRY_POINT = 0x80012f7c;
__main = 0x80013024;
__do_global_dtors = 0x80013094;
InitHeap = 0x800130fc;
VSync = 0x8001310c;
v_wait = 0x80013284;
ChangeClearPAD = 0x8001331c;
ChangeClearRCnt = 0x8001332c;
__ps_libinfo__libc__ = 0x8001333c; // TODO libinfo header for libc.lib, may need to move `puts` under that instead.
puts = 0x80013344;
ResetCallback = 0x8001335c;
InterruptCallback = 0x8001338c;
DMACallback = 0x800133bc;
VSyncCallback = 0x800133ec;
VSyncCallbacks = 0x80013420;
StopCallback = 0x80013450;
RestartCallback = 0x80013480;
CheckCallback = 0x800134b0;
GetIntrMask = 0x800134c0;
SetIntrMask = 0x800134d8;
startIntr = 0x800134f0;
trapIntr = 0x800135c8;
setIntr = 0x80013798;
stopIntr = 0x800138e0;
restartIntr = 0x80013980;
memclr_0 = 0x800139f8;
__ps_libinfo__libapi__ = 0x80013a1c;
_96_remove = 0x80013a24;
ReturnFromException = 0x80013a3c;
ResetEntryInt = 0x80013a4c;
HookEntryInt = 0x80013a5c;
setjmp = 0x80013a6c;
startIntrVSync = 0x80013a7c;
trapIntrVSync = 0x80013ad4;
setIntrVSync = 0x80013b40;
memclr_1 = 0x80013b6c;
startIntrDMA = 0x80013b9c;
trapIntrDMA = 0x80013be8;
setIntrDMA = 0x80013d68;
memclr_2 = 0x80013e14;
SetVideoMode = 0x80013e3c;
GetVideoMode = 0x80013e50;
CdInit = 0x80013e6c;
CdReset2 = 0x80013efc;
def_cbsync = 0x80013f38;
def_cbready = 0x80013f60;
def_cbread = 0x80013f88;
CdStatus = 0x80013fbc;
CdMode = 0x80013fcc;
CdLastCom = 0x80013fdc;
CdLastPos = 0x80013fec;
CdReset = 0x80013ff8;
CdFlush = 0x80014064;
CdSetDebug = 0x80014084;
CdComstr = 0x80014098;
CdIntstr = 0x800140cc;
CdSync = 0x80014100;
CdReady = 0x80014120;
CdSyncCallback = 0x80014140;
CdReadyCallback = 0x80014154;
CdControl = 0x80014168;
CdControlF = 0x800142a4;
CdControlB = 0x800143d8;
CdMix = 0x80014524;
CdGetSector = 0x80014544;
CdGetSector2 = 0x80014564;
CdDataCallback = 0x80014584;
CdDataSync = 0x800145a8;
CdIntToPos = 0x800145c8;
CdPosToInt = 0x800146cc;
getintr = 0x8001474c;
CD_sync = 0x80014ca8;
CD_ready = 0x80014f28;
CD_cw = 0x800151f0;
CD_vol = 0x800155fc;
CD_flush = 0x80015684;
CD_initvol = 0x80015758;
CD_initintr = 0x80015848;
CD_init = 0x80015894;
CD_datasync = 0x80015a74;
CD_getsector = 0x80015bdc;
CD_getsector2 = 0x80015cdc;
CD_set_test_parmnum = 0x80015dc8;
callback = 0x80015dd4;
cb_pause = 0x80015eac;
cb_read = 0x80015ee0;
cb_data = 0x80016154;
cd_read_entry = 0x80016224;
CdReadBreak = 0x8001640c;
CdRead = 0x800165ac;
CdReadSync = 0x80016748;
CdReadCallback = 0x8001684c;
CdReadMode = 0x80016860;
OpenTIM = 0x8001687c;
ReadTIM = 0x8001688c;
OpenTMD = 0x800168f0;
ReadTMD = 0x80016930;
get_tim_addr = 0x80016bd8;
get_tmd_addr = 0x80016cf0;
unpack_packet = 0x80016e64;
ResetGraph = 0x800180fc;
SetGraphDebug = 0x80018270;
SetGraphQueue = 0x800182cc;
GetGraphDebug = 0x80018370;
DrawSyncCallback = 0x80018380;
SetDispMask = 0x800183e0;
DrawSync = 0x80018478;
checkRECT = 0x800184e0;
ClearImage = 0x800185fc;
ClearImage2 = 0x8001868c;
LoadImage = 0x80018724;
StoreImage = 0x80018784;
MoveImage = 0x800187e4;
ClearOTag = 0x8001889c;
ClearOTagR = 0x80018964;
DrawPrim = 0x80018a10;
DrawOTag = 0x80018a6c;
PutDrawEnv = 0x80018adc;
DrawOTagEnv = 0x80018b9c;
GetDrawEnv = 0x80018c74;
PutDispEnv = 0x80018ca8;
GetDispEnv = 0x800191a0;
GetODE = 0x800191d4;
SetTexWindow = 0x80019204;
SetDrawArea = 0x8001923c;
SetDrawOffset = 0x800192bc;
SetPriority = 0x800192fc;
SetDrawStp = 0x80019324;
SetDrawMode = 0x8001934c;
SetDrawEnv = 0x800193a0;
SetDrawEnv2 = 0x80019598;
get_mode = 0x80019808;
get_cs = 0x80019828;
get_ce = 0x800198c0;
get_ofs = 0x80019958;
get_tw = 0x80019974;
_status = 0x800199f4;
_otc = 0x80019a0c;
_clr = 0x80019aec;
_dws = 0x80019d1c;
_drs = 0x80019f58;
_ctl = 0x8001a1d8;
_getctl = 0x8001a1fc;
_cwb = 0x8001a210;
_cwc = 0x8001a250;
_param = 0x8001a298;
_addque = 0x8001a2c8;
_addque2 = 0x8001a2ec;
_exeque = 0x8001a59c;
_reset = 0x8001a7fc;
_sync = 0x8001a94c;
set_alarm = 0x8001aa88;
get_alarm = 0x8001aabc;
_version = 0x8001ac00;
LoadImage2 = 0x8001aca0;
StoreImage2 = 0x8001ad8c;
MoveImage2 = 0x8001ae78;
DrawOTag2 = 0x8001afbc;
_GPU_ResetCallback = 0x8001b0b8;
memset_0 = 0x8001b0e0;
GPU_cw = 0x8001b10c;
__ps_libinfo__libspu__ = 0x8002134c; // SDK version? has 0x44 in SH1
_spu_EVdma = 0x80021354;
_spu_keystat = 0x80021358;
_spu_trans_mode = 0x8002135c;
_spu_rev_flag = 0x80021360;
_spu_rev_reserve_wa = 0x80021364;
_spu_rev_offsetaddr = 0x80021368;
_spu_rev_attr = 0x8002136c;
_spu_RQvoice = 0x80021380;
_spu_RQmask = 0x80021384;
_spu_voice_centerNote = 0x80021388;
_spu_env = 0x800213b8;
_spu_isCalled = 0x800213bc;
_spu_RXX = 0x800213cc;
_spu_madr = 0x800213d0;
_spu_bcr = 0x800213d4;
_spu_chcr = 0x800213d8;
_spu_sys_pcr = 0x800213dc;
_spu_delay = 0x800213e0;
_spu_tsa = 0x800213e4;
_spu_transMode = 0x800213e8;
_spu_addrMode = 0x800213ec;
_spu_mem_mode = 0x800213f0;
_spu_mem_mode_plus = 0x800213f4;
_spu_mem_mode_unit = 0x800213f8;
_spu_mem_mode_unitM = 0x800213fc;
_spu_inTransfer = 0x80021400;
_spu_transferCallback = 0x80021404;
_spu_IRQCallback = 0x80021408;
_spu_dummy_2 = 0x8002140c;
_spu_dma_mode = 0x8002141c;
_spu_transfer_startaddr = 0x80021420;
_spu_transfer_time = 0x80021424;
_spu_rev_startaddr = 0x8002142c;
_spu_AllocBlockNum = 0x8002145c;
_spu_AllocLastNum = 0x80021460;
_spu_memList = 0x80021464;
__initialised = 0x8002146c;
__heapbase = 0x80021470;
__heapsize = 0x80021474;
__text = 0x80021478;
__textlen = 0x8002147c;
__data = 0x80021480;
__datalen = 0x80021484;
__bss = 0x80021488;
__bsslen = 0x8002148c;
__ps_libinfo__libetc__ = 0x80021490; // SDK version? has 0x44 in SH1
gp1_0 = 0x80021498; // gp1
t1_count = 0x8002149c;
Hcount = 0x800214a0;
copyright = 0x800214b0;
intrEnv = 0x80021508;
jtb_0 = 0x80022570; // jtb
jtbp_0 = 0x80022590; // jtbp
i_reg = 0x80022594;
i_mask = 0x80022598;
d_pcr_0 = 0x8002259c; // d_pcr
cbIntrVSync = 0x800225b0;
Vcount = 0x800225d0;
d_icr = 0x800225e0;
cbIntrDMA = 0x800225e4;
madr_top = 0x80022604;
_etc_vmode = 0x80022610;
CD_cbread = 0x80022620;
CD_read_dma_mode = 0x80022624;
setloc = 0x80022630;
__ps_libinfo__libcd__ = 0x800226b0; // 4.3 patch?
CD_cbsync = 0x800226b8;
CD_cbready = 0x800226bc;
CD_debug = 0x800226c0;
CD_status = 0x800226c4;
CD_status1 = 0x800226c8;
CD_nopen = 0x800226cc;
CD_pos = 0x800226d0;
CD_mode = 0x800226d4;
CD_com = 0x800226d5;
DS_active = 0x800226d8; // unused?
CD_comstr = 0x800226dc;
CD_intstr = 0x8002275c;
ComAttr = 0x8002277c;
CD_test_parmnum = 0x80022960; // name guessed from CD_set_test_parmnum fn name, not named inside sdk libs
reg0 = 0x8002297c;
reg1 = 0x80022980;
reg2 = 0x80022984;
reg3 = 0x80022988;
com_delay = 0x8002298c;
spu = 0x80022990;
Intr = 0x80022994;
dv5_delay = 0x800229b0;
d_pcr_1 = 0x800229b4; // d_pcr
d3_madr = 0x800229b8;
d3_bcr = 0x800229bc;
d3_chcr = 0x800229c0;
ReadAttr = 0x800229d0;
__ps_libinfo__libgpu__ = 0x80022a10; // 4.3 patch?
jtb_1 = 0x80022a18; // jtb
jtbp_1 = 0x80022a58; // jtbp
GPU_printf = 0x80022a5c;
GEnv = 0x80022a60;
com = 0x80022af8;
nop = 0x80022b0c;
nop2 = 0x80022b20;
gp0 = 0x80022b64;
gp1_1 = 0x80022b68; // gp1
d2_madr = 0x80022b6c;
d2_bcr = 0x80022b70;
d2_chcr = 0x80022b74;
d6_madr = 0x80022b78;
d6_bcr = 0x80022b7c;
d6_chcr = 0x80022b80;
d_pcr_2 = 0x80022b84; // d_pcr
_qin = 0x80022b88;
_qout = 0x80022b8c;
target = 0x80022b9c;
nenter = 0x80022ba0;
__sdata_start__ = 0x80022bb0;
_ramsize = 0x80022c6c;
_stacksize = 0x80022c70;
__ra_temp = 0x80022c94;
_spu_RQ = 0x800231a0;
Result = 0x800231b8;
Alarm = 0x800231d0;
StMode = 0x800231e8; // unused?
tim = 0x80023200;
ctlbuf = 0x80023258;
_que = 0x80023360;
g_bodyProg = 0x80024b60;
