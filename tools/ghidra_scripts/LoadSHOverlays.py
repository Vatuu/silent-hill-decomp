# @runtime jython
#@author emoose
#@category PSX
#@keybinding
#@menupath
#@toolbar

# Script for loading SH overlays + symbols from the decomp into Ghidra (tested with Ghidra 11.3.2)
# Will also load bodyprog into main memory space, so that bodyprog func/data refs will link up correctly.
#
# Usage:
# - Install ghidra_psx_ldr extension
# - Copy LoadSHOverlays.py into "Ghidra/Features/Jython/ghidra_scripts/" folder
# - Load main SLUS_007.07 file via ghidra_psx_ldr, when prompted to analyze pick No
# - Head to Window > Script Manager, open PSX section, click LoadSHOverlays.py, press play button
# - When prompted for file, select the assets/filetable.c.inc generated by decomp `make setup`
# - It'll then ask if you want to load in overlays/symbols, press Yes to both
# - After loading has finished, open Analysis > Auto Analyze
# - Make sure to uncheck the "PsyQ Signatures" analysis if you loaded in symbols earlier, and start analysis

from ghidra.app.cmd.memory import AddInitializedMemoryBlockCmd
from ghidra.program.disassemble import Disassembler
from ghidra.program.model.symbol import SourceType
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.util.task import TaskMonitor
from javax.swing import JFileChooser
import re
import os
from os.path import basename, dirname, join

MapNames = [
    "map0_s00", "map0_s01", "map0_s02",
    "map1_s00", "map1_s01", "map1_s02", "map1_s03", "map1_s04", "map1_s05", "map1_s06",
    "map2_s00", "map2_s01", "map2_s02", "map2_s03", "map2_s04",
    "map3_s00", "map3_s01", "map3_s02", "map3_s03", "map3_s04", "map3_s05", "map3_s06",
    "map4_s00", "map4_s01", "map4_s02", "map4_s03", "map4_s04", "map4_s05", "map4_s06",
    "map5_s00", "map5_s01", "map5_s02", "map5_s03",
    "map6_s00", "map6_s01", "map6_s02", "map6_s03", "map6_s04", "map6_s05",
    "map7_s00", "map7_s01", "map7_s02", "map7_s03",
]

OverlayAddrs = {
    "bodyprog": 0x80024B60,
    "b_konami": 0x800C9578,
    "map": 0x800C9578,
    "option": 0x801E2600,
    "saveload": 0x801E2600,
    "stf_roll": 0x801E2600,
    "stream": 0x801E2600,
    "hp_safe1": 0x801E7600,
    "s__safe2": 0x801E7600
}

OverlayFileNames = [
    "1ST/BODYPROG.BIN",
    "1ST/B_KONAMI.BIN",
    "VIN/OPTION.BIN",
    "VIN/SAVELOAD.BIN",
    "VIN/STF_ROLL.BIN",
    "VIN/STREAM.BIN",
    "BG/HP_SAFE1.BIN",
    "BG/S__SAFE2.BIN"
]

def askForFile():
    chooser = JFileChooser()

    # If SH_DECOMP_ROOT environment var is set, use that as base folder for the file picker
    decomp_root = os.environ.get("SH_DECOMP_ROOT")
    if decomp_root:
        chooser.setCurrentDirectory(java.io.File(join(decomp_root, "assets")))

    chooser.setSelectedFile(java.io.File("Select overlay .bin, or filetable.c.inc to load all overlays"))
    result = chooser.showOpenDialog(None)
    if result == JFileChooser.APPROVE_OPTION:
        return chooser.getSelectedFile().getAbsolutePath()
    return None

def readOverlayAddressesFromExe():
    # bodyprog/b_konami/map addresses change between releases, luckily game seems to always store them at 0x80010000/0x80010004
    # We'll try reading out those addresses before we start reading in overlays.

    mem = currentProgram.getMemory()
    address_factory = currentProgram.getAddressFactory()
    default_space = address_factory.getDefaultAddressSpace()
    
    print("Reading overlay addresses from executable:")

    try:
        # Read b_konami/map address from 0x80010000
        addr_80010000 = default_space.getAddress(0x80010000)
        map_addr = mem.getInt(addr_80010000) & 0xFFFFFFFF
        print("  b_konami/map address: 0x{:08X}".format(map_addr))
        
        # Read bodyprog address from 0x80010004
        addr_80010004 = default_space.getAddress(0x80010004)
        bodyprog_addr = mem.getInt(addr_80010004) & 0xFFFFFFFF
        print("  bodyprog address: 0x{:08X}".format(bodyprog_addr))
        
        OverlayAddrs["b_konami"] = map_addr
        OverlayAddrs["map"] = map_addr
        OverlayAddrs["bodyprog"] = bodyprog_addr
        
    except Exception as e:
        printerr("Error reading overlay addresses from executable: {}".format(e))
        printerr("Using default addresses instead.")


def carveMemoryBlock(mem, start_addr, length):
    end_addr = start_addr.add(length - 1)
    blocks_to_check = list(mem.getBlocks())

    # First pass, split at start_addr
    for block in blocks_to_check:
        block_start = block.getStart()
        block_end = block.getEnd()

        # Check if the block overlaps the desired range
        if block_end.compareTo(start_addr) >= 0 and block_start.compareTo(end_addr) <= 0:
            # Split at start_addr if block starts before start_addr and contains start_addr
            if block_start.compareTo(start_addr) < 0 and block.contains(start_addr):
                mem.split(block, start_addr)
                break

    # Second pass: split at end_addr + 1
    end_split_addr = end_addr.add(1)
    blocks_to_check = list(mem.getBlocks())

    for block in blocks_to_check:
        block_start = block.getStart()
        block_end = block.getEnd()

        # If block contains end_split_addr and starts before it, split there
        if block_start.compareTo(end_split_addr) < 0 and block.contains(end_split_addr):
            mem.split(block, end_split_addr)
            break

    # Now that memory is split, find the new memory section and remove it
    for block in list(mem.getBlocks()):
        if block.getStart().compareTo(start_addr) == 0:
            mem.removeBlock(block, TaskMonitor.DUMMY)

def createOverlayFromFile(filepath):
    with open(filepath, "rb") as f:
        file_data = f.read()

    mem = currentProgram.getMemory()
    address_factory = currentProgram.getAddressFactory()
    default_space = address_factory.getDefaultAddressSpace()

    block_name = os.path.splitext(os.path.basename(filepath))[0].lower()

    address_factory = currentProgram.getAddressFactory()
    default_space = address_factory.getDefaultAddressSpace()

    block_address = 0
    if block_name.startswith("map") and "_s" in block_name:
        block_address = default_space.getAddress(OverlayAddrs["map"])
    elif block_name in OverlayAddrs:
        block_address = default_space.getAddress(OverlayAddrs[block_name])
    else:
        block_address = askAddress("Start Address", "Enter start address for overlay '{}'".format(block_name))

    txn = currentProgram.startTransaction("Create overlayed block: {}".format(block_name))

    try:
        if block_name.startswith("bodyprog"):
            # Carve hole for bodyprog, so we can load as non-overlay to fix up func/data refs
            carveMemoryBlock(mem, block_address, len(file_data))

        cmd = AddInitializedMemoryBlockCmd(
            block_name, None, filepath, block_address,
            len(file_data), True, True, True, False, 0x00, block_name.startswith("bodyprog") == False
        )

        if not cmd.applyTo(currentProgram):
            printerr("Failed to create memory block.")
            currentProgram.endTransaction(txn, False)
            return

        block = mem.getBlock(block_name)
        mem.setBytes(block.getStart(), file_data)

        currentProgram.endTransaction(txn, True)
        print("Block '{}' created at {}".format(block_name, block_address))
    except Exception as e:
        currentProgram.endTransaction(txn, False)
        printerr("Exception occurred: {}".format(e))

def loadSplatSymbolsFile(sym_path):
    # Extract segment name from filename
    basename = os.path.basename(sym_path)
    segment_match = re.search(r'sym\.(.+?)\.txt$', basename)
    if not segment_match:
        printerr("Could not extract segment name from filename.")
        exit()

    segment_name = segment_match.group(1)

    # Look up the memory space corresponding to the segment
    addr_factory = currentProgram.getAddressFactory()

    if segment_name == "main" or segment_name == "bodyprog":
        space = addr_factory.getDefaultAddressSpace()
    else:
        if segment_name == "credits":
            segment_name = "stf_roll"
        if segment_name == "options":
            segment_name = "option"
        space = addr_factory.getAddressSpace(segment_name)

    if space is None:
        printerr("Memory space '{}' not found in program.".format(segment_name))
        exit()

    # Parse the symbol file
    function_map = {}
    pattern = re.compile(r'(\w+)\s*=\s*(0x[0-9A-Fa-f]+);\s*(//\s*(.*))?')

    with open(sym_path, 'r') as f:
        for line in f:
            match = pattern.search(line)
            if match:
                name = match.group(1)
                addr = int(match.group(2), 16)
                comment = match.group(4) or ""

                function_map[name] = (addr, comment.strip())

    # Create functions and labels
    monitor = ConsoleTaskMonitor()
    disassembler = Disassembler.getDisassembler(currentProgram, monitor, None)
    symbol_table = currentProgram.getSymbolTable()

    for func_name, (addr_val, comment) in function_map.items():
        addr = space.getAddress(addr_val)

        # Remove existing labels at the address (such as PsyQ sigs)
        existing_symbols = symbol_table.getSymbols(addr)
        for symbol in existing_symbols:
            symbol_table.removeSymbolSpecial(symbol)

        currentProgram.getSymbolTable().createLabel(addr, func_name, currentProgram.getGlobalNamespace(), SourceType.USER_DEFINED)

        if "type:func" in comment:
            print("[{}] Disassembling {} at {}".format(segment_name, func_name, addr))
            disassembler.disassemble(addr, None)

            if getFunctionAt(addr) is None:
                createFunction(addr, func_name)
        else:
            print("[{}] Labelling {} at {}".format(segment_name, func_name, addr))


def loadSymbolsFromConfigs(assets_path):
    region = askChoice("Select region to load symbols from", "Pick one:", ["USA", "EUR", "JAP0", "JAP1", "JAP2", "None"], "USA")
    if region == "None":
        return
    configs_path = os.path.normpath(os.path.join(assets_path, "..", "configs", region))

    pattern = re.compile(r"^sym\..*\.txt$")  # regex for filenames like sym.X.txt

    for root, dirs, files in os.walk(configs_path):
        for fname in files:
            if fname.startswith("sym.") and fname.endswith(".txt"):
                loadSplatSymbolsFile(os.path.join(root, fname))

def tryLoadKnownOvl(ovl_path):
    if os.path.isfile(ovl_path):
        print("Loading overlay {}".format(ovl_path))
        createOverlayFromFile(ovl_path)
    else:
        print("File not found: {}".format(ovl_path))

# Entry point
readOverlayAddressesFromExe()
filepath = askForFile()

if filepath:
    filename = basename(filepath).lower()

    if filename.startswith("filetable.c") or filename.startswith("fileenum.h"):
        folder = dirname(filepath)
        vin_path = join(folder, "VIN")

        if askYesNo("Load Overlays", "Do you want to load in overlays?"):
            for name in OverlayFileNames:
                ovl_path = join(folder, name.upper())
                print(ovl_path)
                tryLoadKnownOvl(ovl_path)

            for name in MapNames:
                ovl_path = join(vin_path, name.upper()) + ".BIN"
                print(ovl_path)
                tryLoadKnownOvl(ovl_path)

        if askYesNo("Load Symbols", "Do you want to load splat symbols?"):
            loadSymbolsFromConfigs(folder)
    else:
        createOverlayFromFile(filepath)
else:
    print("No file selected.")
