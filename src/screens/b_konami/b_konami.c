#include "game.h"

#include <psyq/libcd.h>
#include <psyq/libetc.h>

#include "bodyprog/bodyprog.h"
#include "bodyprog/demo.h"
#include "bodyprog/gfx/screen_draw.h"
#include "bodyprog/joy.h"
#include "bodyprog/math/math.h"
#include "bodyprog/memcard.h"
#include "main/fsqueue.h"
#include "screens/b_konami/b_konami.h"
#include "screens/stream/stream.h"

// TODO: Solve the issues related to the padding of the jump table generated by `func_800C99A4`.

s_800CA4F0 D_800CA4F0 = {
    .field_0 = 0,
    .field_1 = 0x1F,
    .field_2 = 0xCE,
    .field_3 = 0xF3
};

void GameState_KonamiLogo_Update(void) // 0x800C95AC
{
    s32 idx;

    if (g_GameWork.gameState_594 != GameState_KonamiLogo)
    {
        return;
    }

    while (g_GameWork.gameState_594 == GameState_KonamiLogo)
    {
        Joy_Update();

        switch (g_GameWork.gameStateStep_598[0])
        {
            case 0:
                Screen_Init(SCREEN_WIDTH * 2, true);

                ScreenFade_Start(true, true, false);
                g_ScreenFadeTimestep = Q12(0.2f);

                // Load `1ST/KONAMI2.TIM` (Konami logo).
                Fs_QueueStartReadTim(FILE_1ST_KONAMI2_TIM, FS_BUFFER_1, &g_KcetLogoImg);
                
                WorldGfx_HarryCharaLoad();
                GameFs_BgItemLoad();
                Map_EffectTexturesLoad(NO_VALUE);

                // Start loading `ANIM/HB_BASE.ANM` (base Harry animations).
                Fs_QueueStartRead(FILE_ANIM_HB_BASE_ANM, FS_BUFFER_0);

                g_GameWork.gameStateStep_598[0]++;
                break;

            case 1:
                if (g_Screen_FadeStatus == g_GameWork.gameStateStep_598[0])
                {
                    g_GameWork.gameStateStep_598[0] = 2;
                }
                break;

            case 2:
                if (g_Controller0->btnsHeld_C != 0 || g_SysWork.timer_1C >= 181)
                {
                    ScreenFade_Start(false, false, false);
                    g_ScreenFadeTimestep            = Q12(0.2f);
                    g_GameWork.gameStateStep_598[0] = 3;
                }
                break;

            case 3:
                if (ScreenFade_IsFinished())
                {
                    Fs_QueueWaitForEmpty();
                    Game_StateSetNext(GameState_KcetLogo);
                }
                break;
        }

        Gfx_KonamiScreenDraw();
        Screen_FadeUpdate();
        Fs_QueueUpdate();
        func_8002EB88();
        func_80033548();
        nullsub_800334C8();
        VSync(SyncMode_Wait);
        GsSwapDispBuff();
        GsDrawOt(&g_OrderingTable2[g_ActiveBufferIdx]);

        idx = GsGetActiveBuff();
        g_ActiveBufferIdx = idx;
        GsOUT_PACKET_P   = (PACKET*)(TEMP_MEMORY_ADDR + (idx << 15));

        GsClearOt(0, 0, &g_OrderingTable0[idx]);
        GsClearOt(0, 0, &g_OrderingTable2[g_ActiveBufferIdx]);
    }
}

s32 func_800C9874(void) // 0x800C9874
{
    s32 saveEntryType0;
    s32 saveEntryType1;

    if (func_80033548() == 0)
    {
        return 1;
    }

    g_ActiveSavegameEntry = (s_SavegameEntry*)SAVEGAME_ENTRY_BUFFER_0;
    saveEntryType0        = g_ActiveSavegameEntry->type_4;

    g_ActiveSavegameEntry = (s_SavegameEntry*)SAVEGAME_ENTRY_BUFFER_1;
    saveEntryType1        = g_ActiveSavegameEntry->type_4;

    // No memory cards.
    if (saveEntryType0 == SavegameEntryType_NoMemCard && saveEntryType1 == SavegameEntryType_NoMemCard)
    {
        return 2;
    }

    if ((saveEntryType0 == SavegameEntryType_OutOfBlocks && (saveEntryType1 == SavegameEntryType_OutOfBlocks || saveEntryType1 == SavegameEntryType_NoMemCard)) ||
        (saveEntryType0 == SavegameEntryType_NoMemCard && saveEntryType1 == SavegameEntryType_OutOfBlocks)) 
    {
        return 3;
    }
    else if (saveEntryType0 == SavegameEntryType_Save || saveEntryType1 == SavegameEntryType_Save)
    {
        g_ActiveSavegameEntry = GetActiveSavegameEntry(g_SelectedSaveSlotIdx);
        g_ActiveSavegameEntry = &g_ActiveSavegameEntry[g_SlotElementSelectedIdx[g_SelectedSaveSlotIdx]];

        D_800BCD40        = g_ActiveSavegameEntry->field_5;
        g_SelectedFileIdx = g_ActiveSavegameEntry->fileIdx_6;
        g_SelectedSaveIdx = g_ActiveSavegameEntry->elementIdx_7;
        return 5;
    }
    
    return 4;
}

void GameState_KcetLogo_Update(void) // 0x800C99A4
{
    while (g_GameWork.gameState_594 == GameState_KcetLogo)
    {
        Joy_Update();

        switch (g_GameWork.gameStateStep_598[0])
        {
            case 0:
                Settings_RestoreDefaults();

                ScreenFade_Start(true, true, false);
                g_ScreenFadeTimestep = Q12(0.2f);

                GameFs_BgEtcGfxLoad();
                Fs_QueueStartRead(FILE_BG_HP_SAFE1_BIN, FS_BUFFER_5);
                Fs_QueueStartRead(FILE_BG_S__SAFE2_BIN, FS_BUFFER_6);
                g_GameWork.gameStateStep_598[0]++;
                break;

            case 1:
                if (ScreenFade_IsNone())
                {
                    Fs_QueueWaitForEmpty();
                    while (g_GameWork.gameStateStep_598[0] < 2)
                    {
                        g_GameWork.gameStateStep_598[0] = func_800C9874();
                        func_8002EB88();
                        VSync(SyncMode_Wait);
                    }
                }
                break;
                
            case 2:
                Fs_QueueStartReadTim(FILE_1ST_NO_MCD_E_TIM, FS_BUFFER_1, &D_800A900C);
                GameFs_StreamBinLoad();
                D_800CA4F0.field_0 = 3;

                g_GameWork.gameStateStep_598[0] = 6u;
                g_SysWork.timer_20              = 0;
                g_GameWork.gameStateStep_598[1] = 0;
                g_GameWork.gameStateStep_598[2] = 0;
                break;

            case 3:
                Fs_QueueStartReadTim(FILE_1ST_NO_BLK_E_TIM, FS_BUFFER_1, &D_800A900C);
                GameFs_StreamBinLoad();
                D_800CA4F0.field_0 = 3;

                g_GameWork.gameStateStep_598[0] = 6u;
                g_SysWork.timer_20              = 0;
                g_GameWork.gameStateStep_598[1] = 0;
                g_GameWork.gameStateStep_598[2] = 0;
                break;

            case 4:
                GameFs_StreamBinLoad();
                GameFs_TitleGfxSeek();
                D_800CA4F0.field_0 = 6;

                g_GameWork.gameStateStep_598[0] = 6u;
                g_SysWork.timer_20              = 0;
                g_GameWork.gameStateStep_598[1] = 0;
                g_GameWork.gameStateStep_598[2] = 0;
                break;

            case 5:
                while (g_GameWork.gameStateStep_598[1] < 3)
                {
                    switch (g_GameWork.gameStateStep_598[1])
                    {
                        case 0:
                            func_8002E94C(2, D_800BCD40, 0, 0);
                            g_GameWork.gameStateStep_598[2] = 0;
                            g_GameWork.gameStateStep_598[1]++;

                        case 1:
                            if (func_8002E990() != 1)
                            {
                                g_GameWork.gameStateStep_598[2] = 0;
                                g_GameWork.gameStateStep_598[1]++;
                            }
                            break;

                        case 2:
                            if (g_GameWorkConst->config_0.optAutoLoad_25)
                            {
                                Fs_QueueStartRead(FILE_VIN_SAVELOAD_BIN, FS_BUFFER_1);
                                Fs_QueueStartSeek(FILE_TIM_SAVELOAD_TIM);
                                D_800CA4F0.field_0 = 4;
                            }
                            else
                            {
                                GameFs_StreamBinLoad();
                                GameFs_TitleGfxSeek();
                                D_800CA4F0.field_0 = 6;
                            }

                            g_GameWork.gameStateStep_598[2] = 0;
                            g_GameWork.gameStateStep_598[1]++;
                            break;
                    }

                    func_80033548();
                    func_8002EB88();
                    VSync(SyncMode_Wait);
                }

                g_GameWork.gameStateStep_598[0] = 6;
                g_SysWork.timer_20              = 0;
                g_GameWork.gameStateStep_598[1] = 0;
                g_GameWork.gameStateStep_598[2] = 0;
                break;

            case 6:
                if (g_Controller0->btnsHeld_C != 0 || g_SysWork.timer_1C > 180)
                {
                    ScreenFade_Start(false, false, false);
                    g_ScreenFadeTimestep = Q12(0.2f);
                    g_GameWork.gameStateStep_598[0]++;
                }
                break;

            case 7:
                if (ScreenFade_IsFinished())
                {
                    Settings_ScreenAndVolUpdate();
                    Screen_Init(SCREEN_WIDTH, false);

                    switch (D_800CA4F0.field_0)
                    {
                        case 4:
                            Fs_QueueStartReadTim(FILE_TIM_SAVELOAD_TIM, FS_BUFFER_7, &g_ItemInspectionImg);
                            break;

                        case 3:
                            break;

                        case 5:
                        default:
                            GameFs_TitleGfxLoad();
                            break;
                    }

                    Demo_SequenceAdvance(0);
                    Demo_DemoDataRead();
                    Fs_QueueWaitForEmpty();

                    g_SysWork.timer_1C = 0;
                    g_SysWork.timer_20 = 0;

                    g_GameWork.gameStateStep_598[1] = 0;
                    g_GameWork.gameStateStep_598[2] = 0;

                    SysWork_StateSetNext(SysState_Gameplay);

                    g_GameWork.gameStateStep_598[0] = g_GameWork.gameState_594;
                    g_GameWork.gameState_594        = D_800CA4F0.field_0;
                    g_GameWork.gameStatePrev_590    = g_GameWork.gameStateStep_598[0];
                    g_GameWork.gameStateStep_598[0] = 0u;
                }
                break;
        }
        
        Gfx_KcetScreenDraw();
        Screen_FadeUpdate();
        Fs_QueueUpdate();
        func_8002EB88();
        func_80033548();
        nullsub_800334C8();
        VSync(SyncMode_Wait);
        GsSwapDispBuff();
        GsDrawOt(&g_OrderingTable2[g_ActiveBufferIdx]);

        g_ActiveBufferIdx = GsGetActiveBuff();
        GsOUT_PACKET_P   = (g_ActiveBufferIdx << 0xF) + (u32)TEMP_MEMORY_ADDR;

        GsClearOt(0, 0, &g_OrderingTable0[g_ActiveBufferIdx]);
        GsClearOt(0, 0, &g_OrderingTable2[g_ActiveBufferIdx]);
    }
}

void Gfx_BootScreenImageSegmentDraw(s_FsImageDesc* image, s32 otz, s32 vramX, s32 vramY, s32 w, s32 h, s32 x, s32 y) // 0x800C9E6C
{
    DR_TPAGE* tPage;
    SPRT*     prim     = (SPRT*)GsOUT_PACKET_P;
    u32       vramBase = image->tPage[1] + (u32)(vramX >> 8) + (((u32)(vramY >> 8)) << 4);
    u32*      addr     = &g_OtTags0[g_ActiveBufferIdx][otz];

    addPrimFast(addr, prim, 4);
    setCodeWord(prim, PRIM_RECT | RECT_TEXTURE, 0x808080);
    setWH(prim, w, h);

    vramX = vramX & 0xFF;
    vramY = vramY & 0xFF;

    //setUV0AndClut(prim, vramX, vramY, image->clutX, image->clutY);
    *(u32*)(&prim->u0) = vramX + (vramY << 8) + (((image->clutY << 6) | ((image->clutX >> 4) & 0x3F)) << 16);

    setXY0Fast(prim, (u16)x, y);

    tPage = (DR_TPAGE*)((u8*)prim + sizeof(SPRT));
    setDrawTPage(tPage, 0, 1, getTPage(image->tPage[0], 0, (vramBase << 6), (((vramBase >> 4) & (1 << 0)) << 8)));
    AddPrim(addr, tPage);

    GsOUT_PACKET_P = (u8*)prim + 28;
}

void Gfx_KonamiScreenDraw(void) // 0x800C9FB8
{
    s32* ptr;

    // Draw Konami logo.
    Gfx_BootScreenImageSegmentDraw(&g_KonamiLogoImg, 0xF, 0, 0, 256, 256, -192, -192);
    Gfx_BootScreenImageSegmentDraw(&g_KonamiLogoImg, 0xF, 256, 0, 128, 256, 64, -192);
    Gfx_BootScreenImageSegmentDraw(&g_KonamiLogoImg, 0xF, 0, 256, 256, 128, -192, 64);
    Gfx_BootScreenImageSegmentDraw(&g_KonamiLogoImg, 0xF, 256, 256, 128, 128, 64, 64);

    // Draw fading overlay tile.
    ptr = &g_OtTags0[g_ActiveBufferIdx][15];
    addPrimFast(ptr, (TILE*)GsOUT_PACKET_P, 3);
    setCodeWord((TILE*)GsOUT_PACKET_P, PRIM_RECT, 0xFFFFFF);
    setXY0Fast((TILE*)GsOUT_PACKET_P, -SCREEN_WIDTH, -SCREEN_HEIGHT);
    setWH((TILE*)GsOUT_PACKET_P, SCREEN_WIDTH * 2, SCREEN_HEIGHT * 2);
    GsOUT_PACKET_P = (PACKET*)((u8*)GsOUT_PACKET_P + sizeof(TILE));
}

void Gfx_KcetScreenDraw(void) // 0x800CA120
{
    u32* ptr;

    // Draw KCET logo.
    Gfx_BootScreenImageSegmentDraw(&g_KcetLogoImg, 0xF, 0, 0, 256, 160, -208, -80);
    Gfx_BootScreenImageSegmentDraw(&g_KcetLogoImg, 0xF, 256, 0, 160, 160, 48, -80);

    // Draw fading overlay tile.
    ptr = &g_OtTags0[g_ActiveBufferIdx][15];
    addPrimFast(ptr, (TILE*)GsOUT_PACKET_P, 3);
    setCodeWord((TILE*)GsOUT_PACKET_P, PRIM_RECT, 0xFFFFFF);
    setXY0Fast((TILE*)GsOUT_PACKET_P, -SCREEN_WIDTH, -SCREEN_HEIGHT);
    setWH((TILE*)GsOUT_PACKET_P, SCREEN_WIDTH * 2, SCREEN_HEIGHT * 2);
    GsOUT_PACKET_P = (PACKET*)((u8*)GsOUT_PACKET_P + sizeof(TILE));
}

// NOTE: This is here to grab padding that should be generated by the jumptable,
// but which in this case is not being generated.
const s32 RodataPad = 0;

// Constants from `LZSS.C`
// https://github.com/mattseabrook/LZSS/blob/f7a5b206bdb1964bbbeb660b464fc3e65e754eb5/1989/LZSS.C
// TODO: This should probably be a separate split, LZSS was likely separate .c or .lib.

#define N         4096 /* size of ring buffer */
#define F         18   /* upper limit for match_length */
#define THRESHOLD 2    /* encode string into position and length if match_length is greater than this */

u8* g_Lzss_Window = FS_BUFFER_1;
s32 D_800CA4F8 = 0;
bool g_Lzss_IsActive = 0;
u8* g_Lzss_CurPosition = 0;
u8* g_Lzss_OutPosition = 0;
s32 g_Lzss_WindowOffset = 0;
u8* g_Lzss_EndPosition = 0;
s32 g_Lzss_CurFlag = 0;

void Lzss_Reset(void) // 0x800CA234
{
    g_Lzss_IsActive = false;
}

s32 Lzss_DecompressedSizeGet(u8* inData) // 0x800CA240
{
    return *(s32*)inData;
}

void Lzss_Init(u8* inData, u8* outData, s32 inDataLen) // 0x800CA24C
{
    s32 i;

    g_Lzss_IsActive     = true;
    g_Lzss_CurPosition  = inData;
    g_Lzss_OutPosition  = outData;
    g_Lzss_EndPosition  = inData + inDataLen;
    g_Lzss_CurPosition += sizeof(s32); // Skip 4 byte uncompressed-size header.

    for (i = 0; i < N; i += sizeof(s32))
    {
        *(s32*)&g_Lzss_Window[i] = 0;
    }

    g_Lzss_WindowOffset = N - F;
    g_Lzss_CurFlag = 0;
}

bool Lzss_IsActive(void) // 0x800CA2B8
{
    return g_Lzss_IsActive;
}

void Lzss_Decode(s32 timeLimit) // 0x800CA2C8
{
    static const s32 timeVar0 = 25;
    static const s32 timeVar1 = 180;

    s32 temp_v0;
    s32 currentTime;
    s32 temp_v1_2;

    s32 var_a1;

    s32 windowOffset; // `g_Lzss_WindowOffset`
    u32 flag; // `g_Lzss_CurFlag`
    s32 expectedTime;

    u32 temp_v0_2;
    u32 temp_v0_3;
    u32 temp_v1;
    
    u8* curPos;  // `g_Lzss_CurPosition`
    u8* endPos; // `g_Lzss_EndPosition`
    u8* windowPos;
    u8* outPos; // `g_Lzss_OutPosition`

    if (g_Lzss_IsActive != true)
    {
        return;
    }

    expectedTime = (timeLimit * 263) - timeVar0; // 263.5 scanlines per frame.

    curPos       = g_Lzss_CurPosition;
    outPos       = g_Lzss_OutPosition;
    windowOffset = g_Lzss_WindowOffset;
    flag         = g_Lzss_CurFlag;
    endPos       = g_Lzss_EndPosition;

    currentTime = VSync(SyncMode_Immediate);

    if (expectedTime - currentTime < timeVar1)
    {
        expectedTime  = currentTime + 468;
        expectedTime  = (expectedTime / 263) * 263;
        expectedTime -= timeVar0;
    }

    while (true)
    {
        if (curPos == endPos) 
        {
            g_Lzss_IsActive = false;
            break;
        }

        // Pause decompression if we've passed the time limit.
        // State vars will be written to globals after breaking, allowing func to be ran again in next frame.
        // (SH only seems to pass `NO_VALUE` to this, so this pause code goes unused.)
        // TODO: Not sure why it checks (1 << 9) is unset yet.
        if (!(flag & (1 << 9)) && VSync(SyncMode_Immediate) > expectedTime && timeLimit != NO_VALUE)
        {
            break;
        }

        // Shift the register; if the 'sentinel' bit at bit 8 is gone, 
        // we've processed 8 bits and need to read a new flag byte.
        flag = flag >> 1;

        if (!(flag & (1 << 8)))
        {
            // Load new flag and set sentinel bits above the 8th bit.
            flag = *curPos++;
            flag |= 0xFF00;
        }

        // The LSB now contains our current flag.
        if (flag & 1)
        {
            // Flag 1 = Copy literal byte
            windowPos  = &g_Lzss_Window[windowOffset];
            temp_v1    = *curPos++;
            *windowPos = temp_v1;
            *outPos++  = temp_v1;
            windowOffset++;
            windowOffset &= (N - 1);
        }
        else
        {
            // Flag 0 = Copy reference (2 bytes)
            if (curPos == (endPos - 1))
            {
                // Not enough room for LZSS reference, end decoding.
                g_Lzss_IsActive = false;
                break;
            }

            temp_v0 = *curPos;
            curPos++;

            temp_v0_2 = *curPos & 0xF0;
            temp_v0_3 = (*curPos & 0xF) + THRESHOLD + 1;
            temp_v0_2 = temp_v0_2 << 4;
            
            var_a1    = temp_v0 | temp_v0_2;
            temp_v1_2 = var_a1 + temp_v0_3;
            curPos++;

            // Copy data from window into output.
            for (; var_a1 < (s16)temp_v1_2; var_a1++, outPos++)
            {
                temp_v0_3 = g_Lzss_Window[var_a1 & (N - 1)];
                
                g_Lzss_Window[windowOffset] = temp_v0_3;
                *outPos = temp_v0_3;

                windowOffset++;
                windowOffset &= (N - 1);
            }
        }
    }

    g_Lzss_CurPosition = curPos;
    g_Lzss_OutPosition = outPos;
    g_Lzss_WindowOffset = windowOffset;
    g_Lzss_EndPosition = endPos;
    g_Lzss_CurFlag = flag;
}
